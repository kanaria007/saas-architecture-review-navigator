# データ更新時の排他制御・ロック戦略が適切に設計されているか？

> Type: Structure  
> Category: データ  
> Audience: 設計初心者 / 設計中のチーム / レビュワー

---

## 背景・概要

同時更新や二重送信によるデータ競合を防ぐには、**適切なロックや排他制御の戦略が不可欠**

特に分散環境では衝突や整合性欠如の原因となりやすいため注意すべき

---

## 例

- version カラムなどを用いた楽観ロックによる競合検知
- 特定処理に対する排他制御をRedisやDBで管理
- Google Cloud Task Queue・AWS SQS・Azure Queue Storage で分散タスクの並行制御

---

## よくある失敗例

- 二重実行防止が考慮されておらず、登録処理などが重複する
- 楽観ロックの導入だけで、衝突時のリカバリが設計されていない
- DBロックの粒度が粗く大量にロックしてパフォーマンスに影響

---

## FAQ

**Q. 楽観ロックと悲観ロックの使い分けは？**

A. 更新競合が少ないなら楽観ロックが基本。競合頻度が高いなら悲観ロック or 分散排他制御を検討するが、BOでは楽観ロックが多い印象

**Q. 楽観ロック失敗時はどうする？**

A. **ユーザー再入力を促す・自動リトライで再実行**など、ユースケースに応じた振る舞いを設計しておくべき

---

## 関連観点

- [データのライフサイクル（作成・更新・削除）が明確か？](https://zenn.dev/kanaria007/articles/93a91d6aae66a1)
